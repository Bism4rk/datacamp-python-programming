def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

new_func = get_new_func(my_special_function)

# Redefine my_special_function() to just print "hello"
def my_special_function():
  print('hello')

new_func()

print('-'*75)

def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

new_func = get_new_func(my_special_function)

# Delete my_special_function()
del(my_special_function)

new_func()

print('-'*75)

def my_special_function():
  print('You are running my_special_function()')
  
def get_new_func(func):
  def call_func():
    func()
  return call_func

# Overwrite `my_special_function` with the new function
my_special_function = get_new_func(my_special_function)

my_special_function()

'''
O código acima demonstra o conceito de fechamentos em Python. Apesar de `my_special_function` ter sido redefinida, a função retornada por `get_new_func` ainda mantém uma referência à versão original de `my_special_function`, permitindo que ela seja chamada mesmo após a redefinição, por causa do fechamento que foi criado.
'''